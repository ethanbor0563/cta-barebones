<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Upcoming Trains</title>
<style>
body { margin:0; font-family: Arial,sans-serif; background:black; color:white; }
header { background-color: #1976d2; color:white; text-align:center; padding:1rem; font-size:2rem; }
.container { max-width:800px; margin:2rem auto; position:relative; height:600px; overflow:hidden; }

/* Base card styling */
.card {
  position:absolute;
  left:0;
  width:95%;
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:1rem;
  color:white;
  border-radius:12px;
  transition: transform 400ms ease, opacity 400ms ease, box-shadow 400ms ease;
  transform-origin: left center; /* scale from left to keep layout neat */
}

/* left and right sections inside a card */
.left { font-size: 2rem; padding-right: 1rem; }
.right { display:flex; gap:0.5rem; align-items:center; }

/* bubbles */
.countdown {
  font-weight:bold;
  font-size: 3rem;          /* big numeric countdown */
  padding:0.3rem 0.6rem;
  border-radius:10px;
  min-width:140px;
  text-align:center;
  background:rgba(255,255,255,0.12);
  color:black;
}
.eta {
  font-size:1.4rem;
  padding:0.25rem 0.5rem;
  border-radius:8px;
  min-width:90px;
  text-align:center;
  background:rgba(255,255,255,0.12);
  color:black;
}


</style>
</head>
<body>
<header>Upcoming Trains</header>
<div class="container" id="train-list"></div>

<script>
/*
  Minimal edits to add smooth scaling for cards with ETA in 12-20 minutes.
  slideTrain() is left untouched (exactly as your working snippet).
*/

const container = document.getElementById('train-list');

let trains = [];            // array of { id, route, dest, eta: Date }
let cardElements = [];      // array (ordered) of DOM elements corresponding to trains[]
const cardHeight = 120;     // base spacing per card (px) â€” adjust to match font sizes
const routeColors = { Red:'#d32f2f', Purple:'#6a1b9a', Blue:'#1976d2' };

let isSliding = false;      // guard while the slide animation executes

// highlight window & scale
const highlightMinMin = 12;   // inclusive
const highlightMaxMin = 20;   // inclusive
const highlightScale = 1.18;  // how much larger the highlighted card is (e.g., 18%)

// format H:MM (12-hour)
function formatHM(d) {
  const h = d.getHours();
  const h12 = ((h + 11) % 12) + 1;
  const mm = d.getMinutes().toString().padStart(2,'0');
  return `${h12}:${mm}`;
}

/* Fetch trains and decide whether to call slideTrain or just refresh */
function fetchTrains(){
  fetch('/api/trains')
    .then(r => r.json())
    .then(data => {
      const newTrains = (data || []).map(t => ({
        id: t.train_id,
        route: t.route,
        dest: t.dest,
        eta: new Date(t.eta_iso)
      }));

      if (isSliding) return; // don't interfere while sliding

      // If the previously-first train disappeared -> trigger slideTrain (user requested behavior)
      const prevFirstId = trains.length ? trains[0].id : null;
      const stillHasPrevFirst = prevFirstId ? newTrains.some(nt => nt.id === prevFirstId) : true;

      if (prevFirstId && !stillHasPrevFirst && cardElements.length) {
        isSliding = true;
        slideTrain(); // your original slide function (kept intact below)
        // give slideTrain time to animate and append new card; then clear guard and resync
        setTimeout(()=>{ isSliding = false; fetchTrains(); }, 1400);
      } else {
        // normal refresh: replace trains and render cards (no forced slide)
        trains = newTrains;
        renderCards(); // create/update DOM elements in order
      }
    })
    .catch(err => console.error('fetchTrains error', err));
}

/* Render DOM cards to match trains[] (used for normal refresh) */
// Replace your existing renderCards() with this function:
function renderCards(){
  // We compute current scales/text now so cards don't flash empty or jump size
  const now = new Date();

  // Build a lookup of existing elements by train id
  const existingById = {};
  cardElements.forEach(el => {
    const id = el.dataset.trainId;
    if (id) existingById[id] = el;
  });

  const newCardElements = [];
  let y = 0;

  // For each train in order, reuse existing element or create a new one
  trains.forEach((t, i) => {
    const id = t.id;
    // compute immediate countdown & scale so the DOM shows correct visual instantly
    const diffSec = Math.max(0, Math.floor((t.eta - now) / 1000));
    const minutes = Math.floor(diffSec / 60);
    const seconds = diffSec % 60;
    const countdownText = `${minutes}:${seconds.toString().padStart(2,'0')}`;
    const etaText = formatHM(t.eta);

    // determine scale right away (matches your highlight window logic)
    const minutesFloat = diffSec / 60;
    const isBig = minutesFloat >= 12 && minutesFloat <= 20; // adjust window if needed
    const scale = isBig ? highlightScale : 1;

    let el = existingById[id];

    if (!el) {
      // create new card element (start it visually below, set initial scale so it doesn't pop)
      el = document.createElement('div');
      el.className = 'card';
      el.dataset.trainId = id;
      el.style.backgroundColor = routeColors[t.route] || '#1976d2';
      // initial content structure with left/right bubbles
      el.innerHTML = `
        <div class="left">${t.route} Line - ${t.dest}</div>
        <div class="right">
          <div class="countdown">${countdownText}</div>
          <div class="eta">${etaText}</div>
        </div>`;
      // set starting transform below screen and with proper immediate scale to avoid jump
      const startY = (cardElements.length * cardHeight) + cardHeight;
      el.style.transform = `translateY(${startY}px) scale(${scale})`;
      el.style.opacity = '0';
      container.appendChild(el);

      // animate it into the computed position
      requestAnimationFrame(() => {
        el.style.transform = `translateY(${y}px) scale(${scale})`;
        el.style.opacity = '1';
      });
    } else {
      // Reuse existing element: update text immediately and move it to correct position+scale
      const left = el.querySelector('.left');
      const cd = el.querySelector('.countdown');
      const et = el.querySelector('.eta');

      if (left) left.textContent = `${t.route} Line - ${t.dest}`;
      if (cd) cd.textContent = countdownText;
      if (et) et.textContent = etaText;

      // ensure background color correct (in case route changed)
      el.style.backgroundColor = routeColors[t.route] || '#1976d2';

      // move + scale smoothly into the new position
      // (we set transform immediately; CSS transition will animate)
      el.style.transform = `translateY(${y}px) scale(${scale})`;
      el.style.opacity = '1';
    }

    newCardElements.push(el);
    // increment y by effective height (base spacing * scale) so stacking accounts for larger cards
    y += cardHeight * scale;
  });

  // Any existing cards not present in the new trains list should slide up and be removed
  Object.keys(existingById).forEach(oldId => {
    if (!trains.find(t => t.id === oldId)) {
      const removedEl = existingById[oldId];
      // animate slide up + fade
      removedEl.style.transform = `translateY(-120%) scale(1)`;
      removedEl.style.opacity = '0';
      setTimeout(() => {
        if (removedEl.parentNode) removedEl.parentNode.removeChild(removedEl);
      }, 1000);
    }
  });

  // Replace the ordered array with the new ordered elements
  cardElements = newCardElements;
}


/* Update countdown text + ETA and recompute scales & positions smoothly */
/* IMPORTANT: this controls both visual size (scale) and vertical translation so transitions are smooth. */
function updateCountdowns(){
  if (isSliding) return; // avoid interfering with slide animation

  const now = new Date();

  // compute scales (1 or highlightScale) based on minutes remaining
  const scales = trains.map(t => {
    if (!t || !t.eta) return 1;
    const diffSec = Math.max(0, Math.floor((t.eta - now) / 1000));
    const minutes = diffSec / 60;
    return (minutes >= highlightMinMin && minutes <= highlightMaxMin) ? highlightScale : 1;
  });

  // compute cumulative vertical positions in px (taking scaled heights into account)
  let y = 0;
  for (let i = 0; i < trains.length; i++) {
    const t = trains[i];
    const card = cardElements[i];
    const s = scales[i] || 1;

    if (!card || !t) {
      // just in case length mismatches
      continue;
    }

    // update countdown bubble and ETA bubble text
    const diff = Math.max(0, Math.floor((t.eta - now) / 1000));
    const m = Math.floor(diff / 60);
    const sSec = diff % 60;
    const countdownEl = card.querySelector('.countdown');
    const etaEl = card.querySelector('.eta');
    if (countdownEl) countdownEl.innerText = `${m}:${sSec.toString().padStart(2,'0')}`;
    if (etaEl) etaEl.innerText = formatHM(t.eta);

    // set transform: translateY(y) scale(s)
    card.style.transform = `translateY(${Math.round(y)}px) scale(${s})`;
    // optional: give highlighted card higher z-index and class for extra styling
    if (s > 1) {
      card.classList.add('big');
      card.style.zIndex = 10;
    } else {
      card.classList.remove('big');
      card.style.zIndex = 1;
    }

    // advance y by effective height (base spacing * scale)
    y += cardHeight * s;
  }
}

/* === DO NOT MODIFY: original slide mechanism kept intact ===
   (this is exactly the function you provided earlier, with the small color bugfix retained)
*/
function slideTrain(){
    if(cardElements.length===0) return;
    const firstCard=cardElements.shift();
    firstCard.style.transform=`translateY(-120%)`;
    firstCard.style.opacity='0';
    trains.shift();

    cardElements.forEach((card,i)=>{
        card.style.transform=`translateY(${i*cardHeight}px)`;
    });

    setTimeout(()=>{
        container.removeChild(firstCard);
        fetch('/api/trains').then(r=>r.json()).then(data=>{
            const newTrainRaw = data[0];
            if(!newTrainRaw) return; // safety
            const newTrain = { id: newTrainRaw.train_id, route: newTrainRaw.route, dest: newTrainRaw.dest, eta: new Date(newTrainRaw.eta_iso) };
            trains.push(newTrain);
            const newCard = document.createElement('div');
            newCard.className = 'card';
            // tiny safe fix: use newTrain when picking color
            if(newTrain.route == "P") {
                newCard.style.backgroundColor=routeColors['Purple']||'#1976d2';
            } else {
                newCard.style.backgroundColor=routeColors[newTrain.route]||'#1976d2';
            }
            newCard.style.transform = `translateY(${cardElements.length*cardHeight + cardHeight}px)`;
            newCard.style.opacity = '1';
            newCard.innerHTML = `<div>${newTrain.route} Line - ${newTrain.dest}</div><div class='countdown'></div>`;
            container.appendChild(newCard);
            requestAnimationFrame(()=>{
                newCard.style.transform = `translateY(${cardElements.length*cardHeight}px)`;
            });
            cardElements.push(newCard);
        });
    },1000);
}
/* === end original slideTrain === */

/* initial load & timers */
fetchTrains();
setInterval(fetchTrains, 60000);   // regular poll
setInterval(updateCountdowns, 1000); // countdown + scaling update every second

</script>
</body>
</html>
