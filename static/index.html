<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Upcoming Trains</title>
<style>
body { margin:0; font-family: Arial,sans-serif; background:black; color:white; }
header { background-color: #1976d2; color:white; text-align:center; padding:1rem; font-size:2rem; }
.container { max-width:800px; margin:2rem auto; position:relative; height:400px; overflow:hidden; }

.card { position:absolute; left:0; width:95%; display:flex; justify-content:space-between; align-items:center; padding:1rem; color:white; border-radius:12px; transition: transform 1s ease, opacity 1s ease; }
.left { font-size: 2rem; padding-right: 1rem; } 
.right { display:flex; gap:0.5rem; align-items:center; }
.countdown { font-weight:bold; font-size: 3rem; padding:0.3rem 0.6rem; border-radius:10px; min-width:140px; text-align:center; background:rgba(255,255,255,0.12); color:black; }
.eta { font-size:1.4rem; padding:0.25rem 0.5rem; border-radius:8px; min-width:90px; text-align:center; background:rgba(255,255,255,0.12); color:black; }
</style>
</head>
<body>
<header>Upcoming Trains</header>
<div class="container" id="train-list"></div>

<script>
/*
 Minimal integration:
 - Keep slideTrain largely untouched (user-provided).
 - Trigger slideTrain only when the previous first train disappears from API.
 - Separate countdown + ETA bubbles and update them every second.
 - Small guard isSliding prevents re-render while a slide is running.
*/

const container = document.getElementById('train-list');

let trains = [];            // array of { id, route, dest, eta: Date }
let cardElements = [];      // array of DOM elements in the same order as 'trains'
const cardHeight = 120;     // increase if your font sizes are large
const routeColors = { Red:'#d32f2f', Purple:'#6a1b9a', Blue:'#1976d2' };

let isSliding = false;      // guard so we don't re-render during slide

function formatHM(d){
    const hrs = d.getHours();
    const h12 = ((hrs + 11) % 12) + 1;
    const mm = d.getMinutes().toString().padStart(2,'0');
    return `${h12}:${mm}`;
}

/* Fetch trains from backend and decide whether to slide or refresh */
function fetchTrains(){
    fetch('/api/trains')
    .then(r=>r.json())
    .then(data=>{
        // Normalize to our shape
        const newTrains = (data || []).map(t => ({
            id: t.train_id,
            route: t.route,
            dest: t.dest,
            eta: new Date(t.eta_iso)
        }));

        // If a slide is running, skip updating now (slide will append new train)
        if(isSliding) return;

        // Determine whether the previous first train disappeared
        const prevFirstId = trains.length ? trains[0].id : null;
        const stillHasPrevFirst = prevFirstId ? newTrains.some(nt => nt.id === prevFirstId) : true;

        if(prevFirstId && !stillHasPrevFirst && cardElements.length){
            // Only trigger slide when the previous top train is gone
            // Mark sliding so render calls won't interfere
            isSliding = true;
            slideTrain(); // NOTE: your slideTrain handles fetching 1 new train and appending it
            // Release the sliding guard after a safe timeout slightly longer than the animation
            setTimeout(()=>{ isSliding = false; fetchTrains(); }, 1500);
        } else {
            // Regular sync: replace trains and rerender DOM (no slide)
            trains = newTrains;
            renderCards();
        }
    })
    .catch(err => {
        console.error('fetchTrains error', err);
    });
}

/* Render all cards from `trains` array (used on normal refresh) */
function renderCards(){
    container.innerHTML = '';
    cardElements = [];

    trains.forEach((t,i) => {
        const card = document.createElement('div');
        card.className = 'card';
        card.style.backgroundColor = routeColors[t.route] || '#1976d2';
        card.style.transform = `translateY(${i*cardHeight}px)`;
        card.style.opacity = '1';

        // left = route & dest; right = countdown bubble + ETA bubble
        card.innerHTML = `<div class="left">${t.route} Line - ${t.dest}</div>
                          <div class="right">
                            <div class="countdown">--:--</div>
                            <div class="eta">${formatHM(t.eta)}</div>
                          </div>`;
        container.appendChild(card);
        cardElements.push(card);
    });
}

/* Update countdown bubble and ETA bubble separately (runs every second) */
function updateCountdowns(){
    const now = new Date();
    for(let i=0; i<cardElements.length; i++){
        const card = cardElements[i];
        const t = trains[i];
        if(!t || !card) continue;
        const diff = Math.max(0, Math.floor((t.eta - now) / 1000));
        const m = Math.floor(diff / 60);
        const s = diff % 60;
        const countdownEl = card.querySelector('.countdown');
        const etaEl = card.querySelector('.eta');
        if(countdownEl) countdownEl.innerText = `${m}:${s.toString().padStart(2,'0')}`;
        if(etaEl) etaEl.innerText = `${formatHM(t.eta)}`;
    }
}

/* === DO NOT MODIFY: original slide mechanism kept intact ===
   (I preserved your function and only made a tiny, safe bg-color line fix.)
*/
function slideTrain(){
    if(cardElements.length===0) return;
    const firstCard=cardElements.shift();
    firstCard.style.transform=`translateY(-120%)`;
    firstCard.style.opacity='0';
    trains.shift();

    cardElements.forEach((card,i)=>{
        card.style.transform=`translateY(${i*cardHeight}px)`;
    });

    setTimeout(()=>{
        container.removeChild(firstCard);
        fetch('/api/trains').then(r=>r.json()).then(data=>{
            const newTrainRaw = data[0];
            if(!newTrainRaw) return; // safety
            const newTrain = { id: newTrainRaw.train_id, route: newTrainRaw.route, dest: newTrainRaw.dest, eta: new Date(newTrainRaw.eta_iso) };
            trains.push(newTrain);
            const newCard = document.createElement('div');
            newCard.className = 'card';
            // small bugfix: use newTrain when choosing color (keeps your original intent)
            if(newTrain.route == "P") {
                newCard.style.backgroundColor = routeColors['Purple'] || '#1976d2';
            } else {
                newCard.style.backgroundColor = routeColors[newTrain.route] || '#1976d2';
            }
            newCard.style.transform = `translateY(${cardElements.length*cardHeight + cardHeight}px)`;
            newCard.style.opacity = '1';
            newCard.innerHTML = `<div>${newTrain.route} Line - ${newTrain.dest}</div><div class='countdown'></div>`;
            container.appendChild(newCard);
            requestAnimationFrame(()=>{
                newCard.style.transform = `translateY(${cardElements.length*cardHeight}px)`;
            });
            cardElements.push(newCard);
        });
    },1000);
}
/* === end original slideTrain === */

/* start normal polling & countdown ticks */
fetchTrains();
setInterval(fetchTrains, 60000);   // regular poll
setInterval(updateCountdowns, 1000); // countdown and ETA updates every second

</script>
</body>
</html>
